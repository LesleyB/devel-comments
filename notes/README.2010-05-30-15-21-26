README

Smart::Comments is good but it writes all its output to STDERR. 
This conflicts with testing frameworks that capture STDERR for testing. 
It probably also doesn't work well with, say, a CGI script. 

The intent of Smart::Comments::Log is to write to a disk file instead. 

The plan is: 

* Write Smart::Comments::Any, 
	which writes to any arbitrary filehandle 
		passed in on the use line. 
	If *STDERR is passed in or no filehandle at all, 
		then behave exactly like vanilla Smart::Comments. 

* Write Smart::Comments::Log 
	to use Log::StdLog and call
	use Smart::Comments::Any *STDLOG.


2010-05-30: 

::Any basically works, although it's not yet fully implemented. 
	TODO: Change all 'print STDERR' and 'warn' to 'print $outfh'.

The current hangup is the question of whether 
	to print a newline before smart output. 
	
	Vanilla tests both STDOUT and STDERR 
	to see if anything's been written to screen since 
	the last smart output; if so, it prints a newline. 
		(I suppose for cleanliness, since the last print may not
			have terminated in a newline.)
	
	Perhaps ::Any should do the same, 
		since caller passes a filehandle opened for writing, 
		and might write to it himself. 
	
	But clearly the test shouldn't be a test of STDOUT || STDERR
		if smart output is going to some file. 
		
	To complicate things, Vanilla seems to make other tests 
		to decide about the preliminary newline. 
	
Related is the question of how Vanilla stores state info in general. 

	I fear that much is stored globally, 
		in such a way as to confuse issues
		if two modules use S::C at the same time. 
	
	My position is that ::Any should be reentrant, 
		with different callers possibly supplying 
		the same or different filehandles. 
	
	Each filehandle must have its own state info 
		if ::Any is going to treat it properly. 
		
	I already have the filehandle itself stashed in caller's namespace. 
	A similar approach may be required, 
		in which a whole hash of state info is stashed. 

-Xiong Changnian 2010-05-30 15:21:10



