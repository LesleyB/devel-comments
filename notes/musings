<xiong> When I started to hack Smart::Comments, I thought I knew what I wanted. Now, I'm not so sure.
<cbstream> [james2vegas] a source filter?
<xiong> My issue revolves around a fairly trivial feature. Since S:::C writes to STDERR, it reasonably enough looks to see if anything has been printed to the screen between calls, and throws a gratuitous newline out there if so. 
<xiong> [james2vegas] Yes, S::C is a source filter. 
<xiong> Since it's possible that whoever printed to the screen didn't even end his print with a newline, this is a reasonable thing to do. So S::C tests both STDOUT and STDERR by doing a tell on them and comparing with a stored prev_tell. 
<xiong> So, now I'm hacking up S::C::Any, intended to support printing debug messages to an arbitrary filehandle. Certainly, if caller opens a filehandle and sends it off, he might also decide to print his own stuff to that filehandle, so similar prophylactic/gratuitous newlines are equally reasonable. 
<xiong> ... similar prophylactic/gratuitous newlines are equally reasonable. 
<xiong> And it's not beyond my capacity to do that. I can tell the fh, store that, compare it, etc. I can even do it by stashing the tell value in caller's namespace, so I'm sure to get the right thing when (rewritten) caller's code does it. 
<xiong> What has me stuck now is the question of it was reasonable for the original S::C to test both STDOUT and STDERR before printing (as it does) only to STDERR. 
<xiong> ... since either might quite reasonably be attached to something other than the screen. 
<xiong> So, my question: Should I test to see if both are attached to the same thing? 
<xiong> Maybe a deeper question is exactly what I mean by that. There's more than one way of STDOUT, for example, not printing to the screen. Even that statement is perilous; I can imagine an environment in which STDOUT went to one window and STDERR to another. 
<xiong> Stop me if I start making sense. 
<xiong> DC's assumption was that both STD would output to the same terminal window and that caller might well be writing to it. My assumption is that every filehandle is independent. 
<xiong> DC also assumes that *every* S::C caller wants smart comments to print to the same screen; that's why he hardwired his output to go to STDERR. My assumption is that each module might call S::C::Any with a different filehandle. 
<xiong> I'm probably complicating the issue by insisting that if S::C::Any is called without a filehandle argument, it should print to STDERR and otherwise behave exactly like vanilla. 

